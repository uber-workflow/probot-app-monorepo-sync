/** Copyright (c) 2019 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import get from 'just-safe-get';
import * as cache from '../cache.js';
import {request} from '../github.js';
import {getPRsFromBranch, getPRFromNumber, getRef} from '../graphql.js';
import {
  getChild,
  getChildren,
  getParentName,
  getRelatedRepoNames,
  getRelation,
  hasChildren,
  hasParent,
  hasRelationship,
} from '../relationships.js';
import {queue, sequential} from '../utils.js';
import {copyCommits, getPRCommitList, syncCommits} from './commits.js';
import {syncStatuses} from './commit-status.js';
import {generateSecondaryPRMeta, syncMeta} from './pr-meta.js';
import {syncState} from './pr-state.js';

const BOT_SIGNATURE =
  '\n\n<sup>Generated by [probot-app-monorepo-sync](https://github.com/uber-workflow/probot-app-monorepo-sync)</sup>';

/**
 * @typedef {{
 *   number: number,
 *   repoName: string,
 * }} PROptType
 */

/**
 * @param {PROptType} pullRequest
 * @returns {string}
 */
export function generateSecondaryBranchName(pullRequest) {
  return [pullRequest.repoName, pullRequest.number].join('/');
}

/**
 * @param {string} branchName
 * @returns {boolean}
 */
export function isSecondaryBranchName(branchName) {
  return /[a-z-]+\/[a-z-]+\/\d+/i.test(branchName);
}

/**
 * @param {string} branchName
 * @returns {PROptType}
 */
export function parseSecondaryBranchName(branchName) {
  const [owner, repo, number] = branchName.split('/');
  return {
    number: parseInt(number),
    repoName: [owner, repo].join('/'),
  };
}

/**
 * @param {PROptType} pullRequest
 * @returns {string}
 */
export function generateKeyFromPR(pullRequest) {
  return [pullRequest.repoName, pullRequest.number].join('/');
}

/**
 * @param {PartnerPRReturnType} result [primaryPR, secondaryPR]
 */
function cachePartnerPRs(result) {
  const [primaryPR, secondaryPR] = result;

  cache.set(`pr-partners.${generateKeyFromPR(primaryPR)}`, result);
  cache.set(`pr-partners.${generateKeyFromPR(secondaryPR)}`, result);
}

/**
 * @typedef {[PROptType, PROptType]} PartnerPRReturnType
 *
 * @param {PROptType} pullRequest
 * @returns {Promise<PartnerPRReturnType | []>} [primaryPR, secondaryPR]
 */
export async function getPartnerPR(pullRequest) {
  const cacheKey = generateKeyFromPR(pullRequest);

  if (cache.get(`pr-partners.${cacheKey}`)) {
    return cache.get(`pr-partners.${cacheKey}`);
  }

  let partnerPR, partnerPRRole;
  const branchName = await getPRFromNumber(
    '{headRefName}',
    pullRequest,
    'repository.pullRequest.headRefName',
  );

  if (isSecondaryBranchName(branchName)) {
    const {
      number: partnerNumber,
      repoName: partnerRepoName,
    } = parseSecondaryBranchName(branchName);
    const partnerPr = await getPRFromNumber(
      '{number}',
      {number: partnerNumber, repoName: partnerRepoName},
      'repository.pullRequest',
    );

    if (partnerPr) {
      partnerPRRole = 'primary';
      partnerPR = {
        number: partnerNumber,
        repoName: partnerRepoName,
      };
    }
  }

  if (!partnerPR) {
    const secondaryBranchName = generateSecondaryBranchName(pullRequest);

    for (const partnerRepoName of getRelatedRepoNames(pullRequest.repoName)) {
      const [partnerNumber, partnerRef] = await Promise.all([
        getPRsFromBranch(
          '{number}',
          {
            branchName: secondaryBranchName,
            includeClosed: true,
            repoName: partnerRepoName,
          },
          'repository.pullRequests.nodes.0.number',
        ),
        getRef(
          '{name}',
          {name: secondaryBranchName, repoName: partnerRepoName},
          'repository.ref',
        ),
      ]);

      // partnerRef is just to ensure the branch exists
      if (partnerNumber && partnerRef) {
        partnerPRRole = 'secondary';
        partnerPR = {
          number: partnerNumber,
          repoName: partnerRepoName,
        };
        break;
      }
    }
  }

  if (partnerPR) {
    let primaryPR, result, secondaryPR;

    if (partnerPRRole === 'primary') {
      primaryPR = partnerPR;
      secondaryPR = pullRequest;
    } else {
      primaryPR = pullRequest;
      secondaryPR = partnerPR;
    }

    result = [primaryPR, secondaryPR];
    cachePartnerPRs(result);
    return result;
  } else {
    return [];
  }
}

/**
 * @param {PROptType} pullRequest
 * @returns {Promise<string | void>} repoName
 */
export async function getSecondaryCandidate(pullRequest) {
  const {repoName} = pullRequest;

  if (hasParent(repoName)) {
    return getParentName(repoName);
  } else if (hasChildren(repoName)) {
    const changedFiles = await getPRFromNumber(
      // TODO: handle pagination to support PRs with more than 100 changed files
      '{files(first: 100) {nodes {path}}}',
      pullRequest,
      'repository.pullRequest.files.nodes',
    );

    for (const child of getChildren(repoName)) {
      const hasChildFiles = changedFiles.some(file =>
        file.path.startsWith(child.path),
      );

      if (hasChildFiles) {
        return child.name;
      }
    }
  }
}

/**
 * @param {PROptType} primaryPR
 * @param {string} secondaryRepoName
 * @returns {Promise<void>}
 */
async function createSecondaryPR(primaryPR, secondaryRepoName) {
  const secondaryBranchName = generateSecondaryBranchName(primaryPR);
  const repoRelation = getRelation(primaryPR.repoName, secondaryRepoName);
  const primaryPRInfo = await getPRFromNumber(
    '{baseRefName, baseRefOid, body, headRefName, headRefOid, title}',
    primaryPR,
    'repository.pullRequest',
  );
  const secondaryBaseRef = await getRef(
    `{
      target {
        oid
        ...on Commit {
          tree {
            oid
          }
        }
      }
    }`,
    {name: primaryPRInfo.baseRefName, repoName: secondaryRepoName},
    'repository.ref.target',
  );

  if (secondaryBaseRef.oid) {
    await sequential([
      // create branch
      async () =>
        request('POST /repos/:repoName/git/refs', {
          repoName: secondaryRepoName,
          data: {
            ref: `refs/heads/${secondaryBranchName}`,
            sha: secondaryBaseRef.oid,
          },
        }).catch(() => {
          console.warn(
            `'${secondaryBranchName}' branch already exists; using for new pr`,
          );
        }),
      // copy commits
      async () => {
        const sourceSubPath =
          repoRelation === 'parent' &&
          getChild(primaryPR.repoName, secondaryRepoName).path;
        const targetSubPath =
          repoRelation === 'child' &&
          getChild(secondaryRepoName, primaryPR.repoName).path;
        const sourceCommits = await getPRCommitList(primaryPR, sourceSubPath);
        const coyOpts = {
          includeTraceSha: true,
          stripMeta: true,
          preserveCommitDate: true,
          source: {
            branch: primaryPRInfo.headRefName,
            commits: sourceCommits,
            repoName: primaryPR.repoName,
          },
          target: {
            baseBranch: primaryPRInfo.baseRefName,
            branch: secondaryBranchName,
            commitSha: secondaryBaseRef.oid,
            commitTreeSha: secondaryBaseRef.tree.oid,
            repoName: secondaryRepoName,
          },
        };

        if (sourceSubPath) {
          coyOpts.source.subPath = sourceSubPath;
        } else if (targetSubPath) {
          coyOpts.target.subPath = targetSubPath;
        }

        return copyCommits(coyOpts);
      },
      // create PR
      async () => {
        const meta = generateSecondaryPRMeta(
          {
            body: primaryPRInfo.body,
            title: primaryPRInfo.title,
          },
          repoRelation,
        );

        return request('POST /repos/:repoName/pulls', {
          repoName: secondaryRepoName,
          data: {
            ...meta,
            head: secondaryBranchName,
            base: primaryPRInfo.baseRefName,
            maintainer_can_modify: true,
          },
        }).then(res => {
          const secondaryPR = {
            number: res.data.number,
            repoName: secondaryRepoName,
          };

          cachePartnerPRs([primaryPR, secondaryPR]);
          return res;
        });
      },
      // post informative comment
      async res => {
        if (repoRelation === 'parent') {
          return request('POST /repos/:repoName/issues/:number/comments', {
            number: primaryPR.number,
            repoName: primaryPR.repoName,
            data: {
              body:
                `Looks like this PR modified files in the \`${
                  getChild(primaryPR.repoName, secondaryRepoName).path
                }\` directory.\n\nA secondary PR has been opened at ${secondaryRepoName}#${
                  res.data.number
                } and will be kept in sync automatically. To update its title or body, edit \`meta.publicTitle\` and \`meta.publicBody\` in the body of this PR.` +
                BOT_SIGNATURE,
            },
          });
        } else {
          return request('POST /repos/:repoName/issues/:number/comments', {
            number: res.data.number,
            repoName: secondaryRepoName,
            data: {
              body:
                `This PR was generated automatically to sync changes from ${
                  primaryPR.repoName
                }#${
                  primaryPR.number
                }.\n\nIf any supplemental changes are needed in this repo, please make them here by pushing to the \`${secondaryBranchName}\` branch.` +
                BOT_SIGNATURE,
            },
          });
        }
      },
    ]);
  }
}

/**
 * @param {SyncPROptsType} opts
 * @returns {Promise<number | void>}
 */
async function getPRNumberFromOpts(opts) {
  let {number: result} = opts;

  if (!result) {
    const {branchName, commitSha, repoName} = opts;

    if (branchName) {
      result = await getPRsFromBranch(
        '{number}',
        {branchName, repoName},
        'repository.pullRequests.nodes.0.number',
      );
    } else if (commitSha) {
      result = await request('GET /repos/:repoName/commits/:commitSha/pulls', {
        repoName,
        commitSha,
        headers: {
          accept: 'application/vnd.github.groot-preview+json',
        },
      }).then(res => get(res, 'data.0.number'));
    }
  }

  return result;
}

/**
 * @typedef {{
 *   branchName?: string,
 *   commitSha?: string,
 *   number?: number,
 *   repoName: string,
 * }} SyncPROptsType
 *
 * @param {SyncPROptsType} opts
 * @param {Array<'commits' | 'meta' | 'state' | 'statuses'>} [syncPoints]
 * @returns {Promise<void>}
 */
export async function syncPR(opts, syncPoints) {
  syncPoints = new Set(syncPoints || ['commits', 'meta', 'state', 'statuses']);

  const {repoName} = opts;

  if (hasRelationship(repoName)) {
    const number = await getPRNumberFromOpts(opts);

    if (number) {
      const pullRequest = {number, repoName};

      await queue(generateKeyFromPR(pullRequest), async () => {
        const [primaryPR, secondaryPR] = await getPartnerPR(pullRequest);

        if (primaryPR && secondaryPR) {
          await sequential([
            () => syncPoints.has('meta') && syncMeta(primaryPR, secondaryPR),
            () =>
              syncPoints.has('statuses') &&
              syncStatuses(primaryPR, secondaryPR),
            () => syncPoints.has('state') && syncState(primaryPR, secondaryPR),
            // TODO: make commits independent of syncState (i.e. have it lookup the state on its own)
            state =>
              state !== 'MERGED' &&
              syncPoints.has('commits') &&
              syncCommits(primaryPR, secondaryPR),
          ]);
        } else {
          const secondaryCandidateName = await getSecondaryCandidate(
            pullRequest,
          );

          if (secondaryCandidateName) {
            await createSecondaryPR(pullRequest, secondaryCandidateName);
          }
        }
      });
    }
  }
}
