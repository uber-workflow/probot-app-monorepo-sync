/** Copyright (c) 2019 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import get from 'just-safe-get';
import * as cache from '../cache.js';
import {request} from '../github.js';
import {getPRsFromBranch, getPRFromNumber, getRef} from '../graphql.js';
import {
  getChild,
  getChildren,
  getParentName,
  getRelatedRepoNames,
  getRelation,
  hasChildren,
  hasParent,
  hasRelationship,
} from '../relationships.js';
import {sequential} from '../utils.js';
import {copyCommits, syncCommits} from './commits.js';
import {syncStatuses} from './commit-status.js';
import {parsePRMeta, syncMeta} from './pr-meta.js';
import {syncState} from './pr-state.js';

const BOT_SIGNATURE =
  '\n\n<sup>Generated by [probot-app-monorepo-sync](https://github.com/uber-workflow/probot-app-monorepo-sync)</sup>';

/**
 * @typedef {{
 *   number: number,
 *   repoName: string,
 * }} PROptType
 */

/**
 * @param {PROptType} pullRequest
 * @returns {string}
 */
export function generateSecondaryBranchName(pullRequest) {
  return [pullRequest.repoName, pullRequest.number].join('/');
}

/**
 * @param {string} branchName
 * @returns {boolean}
 */
export function isSecondaryBranchName(branchName) {
  return /[a-z-]+\/[a-z-]+\/\d+/i.test(branchName);
}

/**
 * @param {string} branchName
 * @returns {PROptType}
 */
export function parseSecondaryBranchName(branchName) {
  const [owner, repo, number] = branchName.split('/');
  return {
    number: parseInt(number),
    repoName: [owner, repo].join('/'),
  };
}

/**
 * @param {PROptType} pullRequest
 * @returns {string}
 */
export function generateKeyFromPR(pullRequest) {
  return [pullRequest.repoName, pullRequest.number].join('/');
}

/**
 * @param {PartnerPRReturnType} result [primaryPR, secondaryPR]
 */
function cachePartnerPRs(result) {
  const [primaryPR, secondaryPR] = result;

  cache.set(`pr-partners.${generateKeyFromPR(primaryPR)}`, result);
  cache.set(`pr-partners.${generateKeyFromPR(secondaryPR)}`, result);
}

/**
 * @typedef {[PROptType, PROptType]} PartnerPRReturnType
 *
 * @param {PROptType} pullRequest
 * @returns {Promise<PartnerPRReturnType | []>} [primaryPR, secondaryPR]
 */
export async function getPartnerPR(pullRequest) {
  const cacheKey = generateKeyFromPR(pullRequest);

  if (cache.get(`pr-partners.${cacheKey}`)) {
    return cache.get(`pr-partners.${cacheKey}`);
  }

  let partnerPR, partnerPRRole;
  const branchName = await getPRFromNumber(
    '{headRefName}',
    pullRequest,
    'repository.pullRequest.headRefName',
  );

  if (isSecondaryBranchName(branchName)) {
    const {
      number: partnerNumber,
      repoName: partnerRepoName,
    } = parseSecondaryBranchName(branchName);
    const partnerPr = await getPRFromNumber(
      '{number}',
      {number: partnerNumber, repoName: partnerRepoName},
      'repository.pullRequest',
    );

    if (partnerPr) {
      partnerPRRole = 'primary';
      partnerPR = {
        number: partnerNumber,
        repoName: partnerRepoName,
      };
    }
  }

  if (!partnerPR) {
    const secondaryBranchName = generateSecondaryBranchName(pullRequest);

    for (const partnerRepoName of getRelatedRepoNames(pullRequest.repoName)) {
      const [partnerNumber, partnerRef] = await Promise.all([
        getPRsFromBranch(
          '{number}',
          {
            branchName: secondaryBranchName,
            includeClosed: true,
            repoName: partnerRepoName,
          },
          'repository.pullRequests.nodes.0.number',
        ),
        getRef(
          '{name}',
          {name: secondaryBranchName, repoName: partnerRepoName},
          'repository.ref',
        ),
      ]);

      // partnerRef is just to ensure the branch exists
      if (partnerNumber && partnerRef) {
        partnerPRRole = 'secondary';
        partnerPR = {
          number: partnerNumber,
          repoName: partnerRepoName,
        };
        break;
      }
    }
  }

  if (partnerPR) {
    let primaryPR, result, secondaryPR;

    if (partnerPRRole === 'primary') {
      primaryPR = partnerPR;
      secondaryPR = pullRequest;
    } else {
      primaryPR = pullRequest;
      secondaryPR = partnerPR;
    }

    result = [primaryPR, secondaryPR];
    cachePartnerPRs(result);
    return result;
  } else {
    return [];
  }
}

/**
 * @param {PROptType} pullRequest
 * @returns {Promise<string | void>} repoName
 */
export async function getSecondaryCandidate(pullRequest) {
  const {repoName} = pullRequest;

  if (hasParent(repoName)) {
    return getParentName(repoName);
  } else if (hasChildren(repoName)) {
    const changedFiles = await getPRFromNumber(
      // TODO: handle pagination to support PRs with more than 100 changed files
      '{files(first: 100) {nodes {path}}}',
      pullRequest,
      'repository.pullRequest.files.nodes',
    );

    for (const child of getChildren(repoName)) {
      const hasChildFiles = changedFiles.some(file =>
        file.path.startsWith(child.path),
      );

      if (hasChildFiles) {
        return child.name;
      }
    }
  }
}

/**
 * @param {PROptType} primaryPR
 * @param {string} secondaryRepoName
 * @returns {Promise<void>}
 */
async function createSecondaryPR(primaryPR, secondaryRepoName) {
  const secondaryBranchName = generateSecondaryBranchName(primaryPR);
  const repoRelation = getRelation(primaryPR.repoName, secondaryRepoName);
  const primaryPRInfo = await getPRFromNumber(
    '{baseRefName, baseRefOid, body, headRefOid, title}',
    primaryPR,
    'repository.pullRequest',
  );
  const secondaryBaseRefOid = await getRef(
    '{target {oid}}',
    {name: primaryPRInfo.baseRefName, repoName: secondaryRepoName},
    'repository.ref.target.oid',
  );

  if (secondaryBaseRefOid) {
    await sequential([
      // create branch
      async () =>
        request('POST /repos/:repoName/git/refs', {
          repoName: secondaryRepoName,
          data: {
            ref: `refs/heads/${secondaryBranchName}`,
            sha: secondaryBaseRefOid,
          },
        }).catch(() => {
          console.warn(
            `'${secondaryBranchName}' branch already exists; using for new pr`,
          );
        }),
      // copy commits
      async () => {
        const opts = {
          includeTraceSha: true,
          stripMeta: true,
          preserveCommitDate: true,
          source: {
            afterSha: primaryPRInfo.headRefOid,
            beforeSha: primaryPRInfo.baseRefOid,
            repoName: primaryPR.repoName,
          },
          target: {
            branch: secondaryBranchName,
            repoName: secondaryRepoName,
            sha: secondaryBaseRefOid,
          },
        };

        if (repoRelation === 'parent') {
          opts.source.subPath = getChild(
            primaryPR.repoName,
            secondaryRepoName,
          ).path;
        } else if (repoRelation === 'child') {
          opts.target.subPath = getChild(
            secondaryRepoName,
            primaryPR.repoName,
          ).path;
        }

        return copyCommits(opts);
      },
      // create PR
      async () => {
        let body, title;

        if (repoRelation === 'parent') {
          const meta = parsePRMeta(primaryPRInfo.body);

          if (meta.publicTitle === 'MATCH') {
            title = primaryPRInfo.title;
          } else if (meta.publicTitle) {
            title = meta.publicTitle;
          } else {
            // this is really just a safety net in case someone forgets to provide the meta
            title = 'Sync pull request from parent repo';
          }

          body = meta.publicBody || '';
        } else if (repoRelation === 'child') {
          title = primaryPRInfo.title;
          body = primaryPRInfo.body;
        }

        return request('POST /repos/:repoName/pulls', {
          repoName: secondaryRepoName,
          data: {
            title,
            head: secondaryBranchName,
            base: primaryPRInfo.baseRefName,
            body: body,
            maintainer_can_modify: true,
          },
        }).then(res => {
          const secondaryPR = {
            number: res.data.number,
            repoName: secondaryRepoName,
          };

          cachePartnerPRs([primaryPR, secondaryPR]);
          return res;
        });
      },
      // post informative comment
      async res => {
        if (repoRelation === 'parent') {
          return request('POST /repos/:repoName/issues/:number/comments', {
            number: primaryPR.number,
            repoName: primaryPR.repoName,
            data: {
              body:
                `Looks like this PR modified files in the \`${
                  getChild(primaryPR.repoName, secondaryRepoName).path
                }\` directory.\n\nA secondary PR has been opened at ${secondaryRepoName}#${
                  res.data.number
                } and will be kept in sync automatically. To update its title or body, edit \`meta.publicTitle\` and \`meta.publicBody\` in the body of this PR.` +
                BOT_SIGNATURE,
            },
          });
        } else {
          return request('POST /repos/:repoName/issues/:number/comments', {
            number: res.data.number,
            repoName: secondaryRepoName,
            data: {
              body:
                `This PR was generated automatically to sync changes from ${
                  primaryPR.repoName
                }#${
                  primaryPR.number
                }.\n\nIf any supplemental changes are needed in this repo, please make them here by pushing to the \`${secondaryBranchName}\` branch.` +
                BOT_SIGNATURE,
            },
          });
        }
      },
    ]);
  }
}

/**
 * @param {SyncPROptsType} opts
 * @returns {Promise<number | void>}
 */
async function getPRNumberFromOpts(opts) {
  let {number: result} = opts;

  if (!result) {
    const {branchName, commitSha, repoName} = opts;

    if (branchName) {
      result = await getPRsFromBranch(
        '{number}',
        {branchName, repoName},
        'repository.pullRequests.nodes.0.number',
      );
    } else if (commitSha) {
      result = await request('GET /repos/:repoName/commits/:commitSha/pulls', {
        repoName,
        commitSha,
        headers: {
          accept: 'application/vnd.github.groot-preview+json',
        },
      }).then(res => get(res, 'data.0.number'));
    }
  }

  return result;
}

/**
 * @typedef {{
 *   branchName?: string,
 *   commitSha?: string,
 *   number?: number,
 *   repoName: string,
 * }} SyncPROptsType
 *
 * @param {SyncPROptsType} opts
 * @param {Array<'commits' | 'meta' | 'state' | 'statuses'>} [syncPoints]
 * @returns {Promise<void>}
 */
export async function syncPR(opts, syncPoints) {
  syncPoints = new Set(syncPoints || ['commits', 'meta', 'state', 'statuses']);

  const {repoName} = opts;

  if (hasRelationship(repoName)) {
    const number = await getPRNumberFromOpts(opts);

    if (number) {
      const pullRequest = {number, repoName};
      const [primaryPR, secondaryPR] = await getPartnerPR(pullRequest);

      if (primaryPR && secondaryPR) {
        await sequential([
          () => syncPoints.has('meta') && syncMeta(primaryPR, secondaryPR),
          () =>
            syncPoints.has('statuses') && syncStatuses(primaryPR, secondaryPR),
          () => syncPoints.has('state') && syncState(primaryPR, secondaryPR),
          // TODO: make commits independent of syncState (i.e. have it lookup the state on its own)
          state =>
            state !== 'MERGED' &&
            syncPoints.has('commits') &&
            syncCommits(primaryPR, secondaryPR),
        ]);
      } else {
        const secondaryCandidateName = await getSecondaryCandidate(pullRequest);

        if (secondaryCandidateName) {
          await createSecondaryPR(pullRequest, secondaryCandidateName);
        }
      }
    }
  }
}

/**
 * @param {PROptType} pullRequest
 * @returns {Promise<void>}
 */
// TODO: add support for `!rebase` comment; make sure to check comments on startup for any non-handled comments
export async function rebase(pullRequest) {
  const {repoName} = pullRequest;
  const pullRequestInfo = await getPRFromNumber(
    `{
      baseRefName
      baseRefOid
      headRefName
      headRefOid
      headRepository {nameWithOwner}
      mergeable
      merged
    }`,
    pullRequest,
    'repository.pullRequest',
  );
  let result;

  if (pullRequestInfo.merged) {
    result = 'ALREADY_MERGED';
  } else if (pullRequestInfo.mergeable !== 'MERGEABLE') {
    result = 'CONFLICTS';
  } else {
    const baseRefOid = await getRef(
      '{target {oid}}',
      {name: pullRequestInfo.baseRefName, repoName},
      'repository.ref.target.oid',
    );

    if (pullRequestInfo.baseRefOid === baseRefOid) {
      result = 'ALREADY_UP_TO_DATE';
    } else {
      result = 'SUCCESS';
      await copyCommits({
        forcePush: true,
        source: {
          afterSha: pullRequestInfo.headRefOid,
          beforeSha: pullRequestInfo.baseRefOid,
          repoName,
        },
        target: {
          branch: pullRequestInfo.headRefName,
          repoName,
          sha: baseRefOid,
        },
      });
    }
  }

  return result;
}
